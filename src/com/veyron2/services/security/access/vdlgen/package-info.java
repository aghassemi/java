
// This file was auto-generated by the veyron vdl tool.
// Source: service.vdl

// Package access defines the service and types for dynamic access control
// in Veyron.  Examples: "allow app to read this photo", "prevent user
// from modifying this file".
//
// Target Developers
//
// Developers creating functionality to share data or services between
// multiple users/devices/apps.
//
// Overview
//
// Every Veyron object supports GetACL and SetACL methods.  An ACL (Access
// Control List) contains principals, groups, and the labels that these
// principals and groups can access for that object.
//
// An object can have multiple names, so GetACL and SetACL can be invoked on
// any of these names, but the object itself has a single ACL.
//
// SetACL completely replaces the ACL.  To perform an atomic read-modify-write
// of the ACL, use the etag parameter.
//   n, err := access.BindObject(name)
//   if err != nil {
//      return err
//   }
//   for {
//     acl, etag, err := n.GetACL()
//     if err != nil {
//       return err
//     }
//     // Add newLabel to the LabelSet.
//     // TODO(kash): Update when we switch labels to strings instead of ints.
//     acl.Principals[newPattern] = acl.Principals[newPattern] | newLabel
//     // Use the same etag with the modified acl to ensure that no other client
//     // has modified the acl since GetACL returned.
//     if err := n.SetACL(acl, etag); err != nil {
//       if verror.Is(err, access.ErrBadEtag) {
//         // Another client replaced the ACL after our GetACL returned.
//         // Try again.
//         continue
//       }
//       return err
//     }
//   }
//
// Conventions
//
// Service implementors should follow the conventions below to be consistent
// with other parts of Veyron and with each other.
//
// All methods that create an object (e.g. Put, Mount, Link) should take an
// optional ACL parameter.  If the ACL is not specified, the new object, O,
// copies its ACL from the parent.  Subsequent changes to the parent ACL are
// not automatically propagated to O.  Instead, a client library could do
// recursive ACL changes if desired.
//
// security.ResolveLabel is required on all components of a name, except the
// last one, in order to access the object referenced by that name.  For
// example, for principal P to access the name "a/b/c", P must have resolve
// access to "a" and "a/b".
//
// security.ResolveLabel means that a principal can traverse that component of
// the name to access the child.  It does not give the principal permission to
// list the children via Glob or a similar method.  For example, a server
// might have an object named "home" with a child for each user of the system.
// If these users were allowed to list the contents of "home", they could
// discover the other users of the system.  That could be a privacy violation.
// Without ResolveLabel, every user of the system would need read access to
// "home" to access "home/<user>".  If the user called Glob("home/*"), it
// would then be up to the server to filter out the names that the user could
// not access.  That could be a very expensive operation if there were a lot
// of children of "home".  ResolveLabel protects these servers against
// potential denial of service attacks on these large, shared directories.
//
// Groups and blessings allow for sweeping access changes.  A group is
// suitable for saying that the same set of principals have access to a set of
// unrelated resources (e.g. docs, VMs, images).  See the Group API for a
// complete description.  A blessing is useful for controlling access to objects
// that are always accessed together.  For example, a document may have
// embedded images and comments, each with a unique name.  When accessing a
// document, the server would generate a blessing that the client would use to
// fetch the images and comments; the images and comments would have this
// blessed identity in their ACLs.  Changes to the document’s ACL are
// therefore “propagated” to the images and comments.
//
// Some services will want a concept of implicit access control.  They are
// free to implement this as is best for their service.  However, GetACL
// should respond with the correct ACL.  For example, a corporate file server
// would allow all employees to create their own directory and have full
// control within that directory.  Employees should not be allowed to modify
// other employee directories.  In other words, within the directory "home",
// employee E should be allowed to modify only "home/E".  The file server
// doesn't know the list of all employees a priori, so it uses an
// implementation-specific rule to map employee identities to their home
// directory.
package com.veyron2.services.security.access.vdlgen;
